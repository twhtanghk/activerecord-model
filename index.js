// Generated by CoffeeScript 1.12.7
(function() {
  var Promise, _, assert, co, http, promiseUntil, promiseWhile, stampit;

  _ = require('lodash');

  assert = require('assert');

  Promise = require('bluebird');

  stampit = require('stampit');

  http = Promise.promisifyAll(require('needle'));

  co = require('co');

  promiseWhile = require('ya-promise-while');

  promiseUntil = function(cond, action) {
    var first, skipFirst;
    first = true;
    skipFirst = function() {
      if (first) {
        first = false;
        return true;
      } else {
        return cond();
      }
    };
    return promiseWhile(skipFirst, action);
  };

  module.exports.token = function*(opts) {
    var body, client, data, ref, scope, statusCode, statusMessage, url, user;
    url = opts.url, client = opts.client, user = opts.user, scope = opts.scope;
    opts = {
      'Content-Type': 'application/x-www-form-urlencoded',
      username: client.id,
      password: client.secret
    };
    data = {};
    if (user != null) {
      data = {
        grant_type: 'password',
        username: user.id,
        password: user.secret,
        scope: scope.join(' ')
      };
    } else {
      data = {
        grant_type: 'client_credentials'
      };
    }
    ref = (yield module.exports.api().post(url.token, data, opts)), statusCode = ref.statusCode, statusMessage = ref.statusMessage, body = ref.body;
    assert(statusCode === 200 && (body.error == null), statusMessage + ": " + body);
    return body.access_token;
  };

  module.exports.verify = function*(opts) {
    var body, ref, result, scope, statusCode, statusMessage, token, url;
    url = opts.url, scope = opts.scope, token = opts.token;
    opts = {
      headers: {
        Authorization: "Bearer " + token
      }
    };
    ref = (yield module.exports.api().get(url.verify, null, opts)), statusCode = ref.statusCode, statusMessage = ref.statusMessage, body = ref.body;
    assert(statusCode === 200, statusMessage + ": " + body);
    result = _.intersection(scope, body.scope.split(' '));
    assert(result.length === scope.length, "Unauthorizated access to " + scope);
    return body;
  };

  module.exports.validToken = function*(opts) {
    var action, cond;
    cond = function() {
      return !opts.token;
    };
    action = function() {
      return co(function*() {
        var err, getToken, scope, token, url, verified;
        while (true) {
          try {
            token = opts.token, getToken = opts.getToken, url = opts.url, scope = opts.scope;
            verified = (yield module.exports.verify(opts));
            return opts.token;
          } catch (error) {
            err = error;
            opts.token = (yield getToken());
          }
        }
      });
    };
    return (yield promiseUntil(cond, action).then(function() {
      return opts.token;
    }));
  };

  module.exports.api = function() {
    var stamp;
    return stamp = stampit().compose(http).statics({
      get: function*(url, data, opts) {
        if (opts == null) {
          opts = {};
        }
        if (data != null) {
          if (opts.headers == null) {
            opts.headers = {};
          }
          _.extend(opts.headers, {
            'Content-Type': 'application/json',
            'x-http-method-override': 'get'
          });
          return (yield http.postAsync(url, data, opts));
        } else {
          return (yield http.getAsync(url, opts));
        }
      },
      put: function*(url, data, opts) {
        return (yield http.putAsync(url, data, opts));
      },
      post: function*(url, data, opts) {
        return (yield http.postAsync(url, data, opts));
      },
      'delete': function*(url, data, opts) {
        return (yield http.deleteAsync(url, data, opts));
      }
    });
  };

  module.exports.authApi = function(getToken) {
    var api, token;
    token = function*(opts) {
      var ret;
      ret = {
        rejectUnauthorized: false,
        headers: {
          Authorization: "Bearer " + ((yield getToken()))
        }
      };
      return _.extend(ret, opts);
    };
    api = module.exports.api();
    return stampit().compose(api).statics({
      get: function*(url, data, opts) {
        opts = (yield token(opts));
        return (yield api.get(url, null, opts));
      },
      put: function*(url, data, opts) {
        return (yield api.put(url, data, (yield token(opts))));
      },
      post: function*(url, data, opts) {
        return (yield api.post(url, data, (yield token(opts))));
      },
      'delete': function*(url, data, opts) {
        return (yield api["delete"](url, null, (yield token(opts))));
      }
    });
  };

  module.exports.model = function(baseUrl) {
    var stamp;
    return stamp = stampit().init(function(props) {
      return _.extend(this, this.parse(props));
    }).methods({
      getStamp: function() {
        return stamp;
      },
      isNew: function() {
        return this[this.getStamp().idAttribute] == null;
      },
      parse: function(data) {
        if (data == null) {
          data = {};
        }
        return data;
      },
      fetch: function*() {
        var res;
        res = (yield stamp.api.get(stamp.url('read', {
          id: this[this.getStamp().idAttribute]
        })));
        assert(res.statusCode === 200, res.statusMessage + ": " + res.body);
        return _.extend(this, this.parse(res));
      },
      save: function*(values) {
        var res;
        if (values == null) {
          values = {};
        }
        _.extend(this, values);
        if (this.isNew()) {
          res = (yield stamp.api.post(stamp.url('create'), this));
          assert(res.statusCode === 201, res.statusMessage + ": " + res.body);
          return _.extend(this, this.parse(res.body));
        } else {
          res = (yield stamp.api.put(stamp.url('update', {
            id: this[this.getStamp().idAttribute]
          }), this));
          assert(res.statusCode === 200, res.statusMessage + ": " + res.body);
          return _.extend(this, this.parse(res.body));
        }
      },
      destroy: function*() {
        var res;
        res = (yield stamp.api["delete"](stamp.url('delete', {
          id: this[this.getStamp().idAttribute]
        })));
        assert(res.statusCode === 200, res.statusMessage + ": " + res.body);
        return this;
      }
    }).statics({
      idAttribute: 'id',
      baseUrl: baseUrl,
      api: module.exports.api(),
      use: function(api) {
        this.api = api;
        return this;
      },
      url: function(method, params) {
        var URL, obj, path;
        if (method == null) {
          method = 'list';
        }
        if (params == null) {
          params = {
            id: '.'
          };
        }
        _.defaults(params, {
          id: '.'
        });
        URL = require('url');
        path = require('path');
        obj = URL.parse(this.baseUrl);
        obj.pathname = path.join(obj.pathname, params.id.toString());
        obj.query = _.omit(params, 'id');
        return URL.format(obj);
      },
      fetchOne: function*(id) {
        var props;
        props = {};
        props[this.idAttribute] = id;
        return (yield this(props).fetch());
      },
      fetchAll: function*() {
        var action, cond, count, results, self, skip;
        self = this;
        skip = 0;
        count = 0;
        results = [];
        cond = function() {
          return skip < count;
        };
        action = function() {
          return co(self.api.get(self.url('list', {
            skip: skip
          }))).then(function(res) {
            var body, data;
            assert(res.statusCode === 200, res.statusMessage + ": " + res.body);
            body = res.body;
            if (Array.isArray(body)) {
              data = {
                count: body.length,
                results: body
              };
              body = data;
            }
            skip = skip + count;
            return count = body.count, results = body.results, body;
          });
        };
        return (yield promiseUntil(cond, action).then(function() {
          return function*() {
            var i, j, len, results1;
            results1 = [];
            for (j = 0, len = results.length; j < len; j++) {
              i = results[j];
              results1.push((yield i));
            }
            return results1;
          };
        }));
      }
    });
  };

}).call(this);
